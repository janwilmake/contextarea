{
  "openapi": "3.1.0",
  "$schema": "https://ref.actionschema.com/openapi.json",
  "info": {
    "title": "N Lang File Transformer API",
    "description": "# N lang - The AI Compilation Layer for Natural Language Programming\n\nDescription: N lang is an AI Layer capable of tranforming hierarchical files into AI-generated static assets and scripts.\n\nGoals:\n\n- Extensions can be stacked to recursively generate derivatives from a (natural language) source.\n- Keep track of dependencies between files to calculate the most efficient way of generating\n- Keep track of what's been generated and what hasn't yet, with a notion of what needs to be lazy and what needs to be proactively generated. Also keep track of what needs to be re-generated when a new update comes to the source-text.\n- When having a \"lazy strategy\", have the ability to generate and serve static files in realtime using a \"generative fallback\" while keeping these assets ready for the next deployment to be truly static.\n- Full flexibility in choosing generation configuration (LLM and prompts) using a github template repo.\n- Doing this as fast, efficient, and cheap as possible.\n- Clear distinction between source 'routes' and destination 'asset paths'\n\nMuch of the above has already been implemented in iRFC-cloud, albeit using a not-so-scalable vector database, and a custom root handler as source of truth, there is not much to be added.\n\nThe interface we want is as follows:\n\n- input:\n  - github (or other) repo-branch\n  - optional: a previous successful deployment date from same source to same destination\n- preprocessing:\n  - get files\n  - calculate diff\n- internal:\n  - prepare file data\n  - calculate workflow\n  - execute workflow\n- output:\n  - a file object of static files for the destination\n  - a lazy fallback URL (can be inside of a config file)\n- post-processing:\n  - submit this new output to a repo/branch on github or similar or into a zip or r2 storage object. we now just need an uithub URL as response\n\nThe beauty is that, including the pre and post-processing steps, it's a URL-to-URL function now.\n\nThe output is to be used in a way where we:\n\n- layover the template\n- add lazily generated files from r2\n- bundle to a worker executable\n- (re)deploy.\n\n# How to use\n\nDefinition files use a stacked extension pattern where each extension transforms the content:\n\n```\nexample.json.url.md.md\n↓\nexample.json.url.md\n↓\nexample.json.url\n↓\nexample.json\n```\n\n## Extension Types\n\n### .md (Markdown)\n\n- Primary extension for natural language definitions\n- Contains instructions for AI to generate the target format\n- Can reference context files that the AI should consider\n- Must output content in the target extension's format (specified by previous extension)\n- Will be processed by LLM with contextual awareness\n\n### .url\n\n- Used to proxy content from another URL\n- Content should be a complete URL or relative path\n- Supports parameter substitution using [param] syntax\n- Example: `https://api.example.com/data/[id]`\n\n### .ts/.js (Coming Soon)\n\n- Will support JavaScript/TypeScript transformations\n- Currently returns \"not supported\" error",
    "version": "1.0.0"
  },
  "servers": [
    { "url": "https://api.nlang.dev" },
    { "url": "http://localhost:3000" }
  ],
  "paths": {
    "/transformRoute": {
      "post": {
        "summary": "Transform Route",
        "description": "Transforms content using specified LLM configuration and routing information",
        "operationId": "transformRoute",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompileRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully compiled content",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["stack"],
                  "properties": {
                    "stack": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Step"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": ["stack"],
                  "properties": {
                    "stack": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Step"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/transform": {
      "get": {
        "summary": "Transform File Object",
        "description": "Transforms all files given using the nlang compiler.",
        "operationId": "transform",
        "parameters": [
          {
            "name": "fileObjectUrl",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "File Object to be transformed"
            }
          },
          {
            "name": "configFileUrl",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "URL to a config yaml file. Will also look in the file object itself"
            }
          },
          {
            "name": "fileObjectApiKey",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Authorization bearer token to retrieve the file object (if required)"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The changes and/or result. Can be accepted in multiple formats:\n\n- **application/x-patch (default)**: Will just respond with a string that can be applied using 'git apply'. This is the default when using curl.\n- **application/json**: will respond with a 'ContentResponse' that contains a file object, a diff, and the operations done to get here.\n- **text/event-stream**: Will stream the result back with incremental updates. The 'final' response will be what you would normally get when using 'application/json'",
            "content": {
              "application/x-patch": {
                "schema": {
                  "type": "string",
                  "description": "A diff file (without metadata) from the previous file object that, when applied, provides the new file object. can be applied using 'git apply'"
                }
              },

              "application/json": {
                "schema": {
                  "$ref": "https://ref.actionschema.com/file-object.json"
                }
              },

              "text/event-stream": {
                "schema": {
                  "type": "object",
                  "description": "Event stream where each event is a JSON object prefixed with 'data: '",

                  "oneOf": [
                    {
                      "type": "object",
                      "description": "Information event containing iteration and token usage details",
                      "properties": {
                        "type": {
                          "type": "string",
                          "enum": ["info"],
                          "description": "Indicates this event contains progress information"
                        },
                        "info": {
                          "type": "object",
                          "properties": {
                            "iteration": {
                              "type": "number",
                              "description": "Current iteration number"
                            },
                            "tokenCount": {
                              "type": "number",
                              "description": "Approximate token count for current response"
                            },
                            "matchCount": {
                              "type": "number",
                              "description": "Number of file operations in current iteration"
                            }
                          },
                          "required": ["iteration", "tokenCount", "matchCount"]
                        }
                      },
                      "required": ["type", "info"]
                    },
                    {
                      "type": "object",
                      "description": "File operation event containing changes for a single file",
                      "properties": {
                        "type": {
                          "type": "string",
                          "enum": ["operation"],
                          "description": "Indicates this event contains a file operation"
                        },
                        "operation": {
                          "$ref": "https://ref.actionschema.com/file-operation.json"
                        }
                      },
                      "required": ["type", "operation"]
                    },
                    {
                      "type": "object",
                      "description": "Final event containing complete file changes and PR details",
                      "properties": {
                        "type": {
                          "type": "string",
                          "enum": ["final"],
                          "description": "Indicates this is the final event with complete changes"
                        },
                        "data": {
                          "$ref": "https://ref.actionschema.com/file-object.json"
                        }
                      },
                      "required": ["type", "data"]
                    }
                  ]
                }
              }
            }
          },
          "423": {
            "description": "The requested is resource is being calculated. Please retry in a while",
            "content": { "text/plain": { "schema": { "type": "string" } } }
          },
          "400": {
            "description": "Invalid input parameters",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Invalid API keys",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "FileObject was not found",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [{}]
      }
    },

    "/dependencies": {
      "get": {
        "operationId": "dependencies",
        "summary": "Get dependency object for a file object",
        "description": "Runs the context prompt for each file",

        "parameters": [
          {
            "name": "fileObjectUrl",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "File Object to be transformed"
            }
          },
          {
            "name": "originUrl",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "OriginURL where to find the file that may be used for the external urls"
            }
          },
          {
            "name": "llmApiKey",
            "in": "query",
            "required": false,
            "schema": { "type": "string" }
          },
          {
            "name": "llmBasePath",
            "in": "query",
            "required": false,
            "schema": { "type": "string" }
          },
          {
            "name": "llmModelName",
            "in": "query",
            "required": false,
            "schema": { "type": "string" }
          },
          {
            "name": "fileObjectApiKey",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Authorization bearer token to retrieve the file object (if required)"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An object with keys being paths, value being multiple arrays with dependencies.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DependencyObject"
                }
              },
              "text/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/DependencyObject"
                }
              }
            }
          }
        }
      }
    },
    "/dependenciesRoute": {
      "get": {
        "operationId": "dependenciesRoute",
        "summary": "Get dependency object for a file",
        "description": "Will get dependency-object for a specific file. Will first get all dependencies, then filter for this file.",
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Route to find the dependencies for "
            }
          },
          {
            "name": "fileObjectUrl",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "File Object to be transformed"
            }
          },
          {
            "name": "configFileUrl",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "URL to a config yaml file. Will also look in the file object itself"
            }
          },
          {
            "name": "fileObjectApiKey",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Authorization bearer token to retrieve the file object (if required)"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A dependency object",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DependencyObject"
                }
              },
              "text/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/DependencyObject"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ConfigFile": { "$ref": "schema.yaml" },
      "CompileRequest": {
        "type": "object",
        "required": ["originalPath", "route", "content"],
        "properties": {
          "originalPath": {
            "type": "string",
            "description": "Path to the original sourcetext of the route that was loaded, with dynamic params"
          },
          "route": {
            "type": "string",
            "description": "Actual requested URL for the nlang-compatible server, with filled params"
          },
          "content": {
            "type": "string",
            "description": "Content at the originalPath"
          },
          "routeApiKey": {
            "type": "string",
            "description": "Optional API key for accessing route content",
            "nullable": true
          },
          "config": { "$ref": "#/components/schemas/ConfigFile" }
        }
      },
      "Step": {
        "type": "object",
        "properties": {
          "input": {
            "$ref": "#/components/schemas/StepInput"
          },
          "output": {
            "$ref": "#/components/schemas/StepOutput"
          }
        },
        "required": ["output"]
      },
      "StepInput": {
        "type": "object",
        "required": [
          "pathAtStep",
          "routeAtStep",
          "llmBasePath",
          "llmModelName",
          "llmApiKey"
        ],
        "properties": {
          "pathAtStep": {
            "type": "string",
            "description": "Path to the source at this step (may include dynamic route filenames)"
          },
          "routeAtStep": {
            "type": "string",
            "description": "Route that was loaded. params can be inferred from this"
          },
          "content": {
            "type": "string",
            "description": "content of the sourcetext"
          },
          "routeApiKey": {
            "type": "string",
            "description": "Optional API key for accessing route content",
            "nullable": true
          },
          "llmBasePath": {
            "type": "string",
            "description": "Base path for LLM API endpoint"
          },
          "llmModelName": {
            "type": "string",
            "description": "Name of the LLM model to use"
          },
          "llmApiKey": {
            "type": "string",
            "description": "API key for accessing the LLM service"
          }
        }
      },
      "StepOutput": {
        "type": "object",
        "properties": {
          "status": {
            "type": "integer",
            "description": "HTTP status code"
          },
          "headers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Response headers"
          },
          "content": {
            "type": "string",
            "description": "Output content"
          },
          "url": {
            "type": "string",
            "description": "URL incase we have content proxied from another URL. URL is normalised with variables already"
          },
          "contextUrls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Related context URLs"
          }
        }
      },
      "DependencyObject": {
        "description": "An object where values refer to keys in the same object they depend on",
        "type": "object",
        "additionalProperties": {
          "type": "object",
          "properties": {
            "contextUrls": {
              "type": "array",
              "items": { "type": "string" }
            },
            "generationUrls": {
              "type": "array",
              "items": { "type": "string" }
            },
            "status": { "type": "number" },
            "error": { "type": "string" },
            "resultUrl": { "type": "string" }
          }
        }
      }
    }
  }
}
